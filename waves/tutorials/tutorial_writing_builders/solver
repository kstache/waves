#!/usr/bin/env python
"""Example for common commercial and research solver behavior and handling"""

import sys
import pathlib
import argparse

import yaml


_version = "1.0.0"
_project_name = pathlib.Path(__file__).stem
_project_name_version = f"{_project_name} {_version}"
_output_file_extension = ".out"


def main():
    parser = get_parser()
    subcommand_list = parser._subparsers._group_actions[0].choices.keys()
    args = parser.parse_args()

    if args.subcommand not in subcommand_list:
        parser.print_help()
    else:
        subcommand = globals()[args.subcommand]
        subcommand(args)


def name_output_file(input_file: pathlib.Path, output_file: pathlib.Path) -> pathlib.Path:
    if output_file is None:
        output_file = input_file.with_suffix(_output_file_extension)
    return output_file


def read_input(input_file: pathlib.Path) -> dict:
    input_file.resolve()
    if not input_file.is_file():
        print("input file '{input_file}' does not exist", file=sys.stderr)
    try:
        with open(input_file, "r") as input_handle:
            configuration = yaml.safe_load(input_handle)
    except yaml.parser.ParserError as err:
        print(f"Error loading '{input_file}'. Check the YAML syntax.\nyaml.parser.ParserError: {err}", file=sys.stderr)
        sys.exit(1)
    return configuration


def configure(args):
    configuration = read_input(args.input_file)
    if "routine" in configuration and configuration["routine"].lower() != args.subcommand.lower():
        print(
            f"requested routine '{configuration['routine']}' does not match subcommmand '{args.subcommand}'",
            file=sys.stderr
        )
        sys.exit(2)
    configuration["version"] = _project_name_version
    return configuration


def implicit(args):
    configuration = configure(args)
    output_file = name_output_file(args.input_file, args.output_file)
    with open(output_file, 'w') as output_writer:
        output_writer.write(yaml.safe_dump(configuration))


def explicit(args):
    configuration = configure(args)
    output_file = name_output_file(args.input_file, args.output_file)
    with open(output_file, 'w') as output_writer:
        output_writer.write(yaml.safe_dump(configuration))


def merge(args):
    pass


def positive_int(argument):
    """Type function for argparse - positive integers

    :param str argument: string argument from argparse

    :returns: argument
    :rtype: int

    :raises ValueError:

        * The argument can't be cast to int
        * The argument is less than 0
    """
    MINIMUM_VALUE = 0
    try:
        argument = int(argument)
    except ValueError:
        raise argparse.ArgumentTypeError("invalid integer value: '{}'".format(argument))
    if not argument > MINIMUM_VALUE:
        raise argparse.ArgumentTypeError("invalid positive integer: '{}'".format(argument))
    return argument


def get_parser():
    cli_description = "Dummy solver with file handling behavior similar to numeric solvers"
    main_parser = argparse.ArgumentParser(description=cli_description)
    main_parser.add_argument(
        "-V", "--version",
        action="version",
        version=_project_name_version
    )

    subcommand_parser_parent = argparse.ArgumentParser(add_help=False)
    required_named = subcommand_parser_parent.add_argument_group('required named arguments')
    required_named.add_argument(
        "-i", "--input-file", type=pathlib.Path, required=True,
        help=f"The {_project_name} input file, e.g. ``input_file.yaml``"
    )
    subcommand_parser_parent.add_argument(
        "-o", "--output-file", type=pathlib.Path, default=None, required=False,
        help=f"The {_project_name} results file. Extension is always replaced with ``{_output_file_extension}``. " \
             f"If none is provided, uses the pattern ``input_file{_output_file_extension}``"
    )
    subcommand_parser_parent.add_argument(
        "-j", "--jobs", type=positive_int, default=1, required=False,
        help=f"The number of threads to use (default: %(default)s)"
    )

    subparsers = main_parser.add_subparsers(
        # So args.subcommand will contain the name of the subcommand called
        title="subcommands",
        metavar="{subcommand}",
        dest="subcommand"
    )

    subparsers.add_parser(
        "implicit",
        help=f"Execute the {_project_name} implicit routine",
        parents=[subcommand_parser_parent]
    )

    subparsers.add_parser(
        "explicit",
        help=f"Execute the {_project_name} explicit routine",
        parents=[subcommand_parser_parent]
    )

    merge_parser = subparsers.add_parser(
        "merge",
        help=f"Merge output files (unimplemented)",
    )

    return main_parser

if __name__ == "__main__":
    main()
