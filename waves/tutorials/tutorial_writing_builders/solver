#!/usr/bin/env python
"""Example for common commercial and research solver behavior and handling"""

import sys
import pathlib
import argparse

import yaml


_version = "1.0.0"
_project_name = pathlib.Path(__file__).stem
_project_name_version = f"{_project_name} {_version}"
_output_file_extension = ".out"
_log_file = "solver.log"


def main():
    """Main function implementing the command line interface and program flow"""
    parser = get_parser()
    subcommand_list = parser._subparsers._group_actions[0].choices.keys()
    args = parser.parse_args()

    if args.subcommand not in subcommand_list:
        parser.print_help()
    else:
        subcommand = globals()[args.subcommand]
        subcommand(args)


def name_output_file(input_file: pathlib.Path, output_file: pathlib.Path) -> pathlib.Path:
    """Create the output file name from the input file if not specified"""
    if output_file is None:
        output_file = input_file.with_suffix(_output_file_extension)
    return output_file


def read_input(input_file: pathlib.Path) -> dict:
    """Return the configuration by reading the input file and handling common errors"""
    input_file.resolve()
    if not input_file.is_file():
        print("input file '{input_file}' does not exist", file=sys.stderr)
    try:
        with open(input_file, "r") as input_handle:
            configuration = yaml.safe_load(input_handle)
    except yaml.parser.ParserError as err:
        print(f"Error loading '{input_file}'. Check the YAML syntax.\nyaml.parser.ParserError: {err}", file=sys.stderr)
        sys.exit(1)
    return configuration


def configure(args):
    """Return the configuration with appended executable information"""
    configuration = read_input(args.input_file)
    if "routine" in configuration and configuration["routine"].lower() != args.subcommand.lower():
        print(
            f"requested routine '{configuration['routine']}' does not match subcommmand '{args.subcommand}'",
            file=sys.stderr
        )
        sys.exit(2)
    configuration["routine"] = args.subcommand.lower()
    configuration["version"] = _project_name_version
    with open(_log_file, "w+") as log_writer:
        log_writer.write(f"{configuration['version']}\n{configuration['routine']}\n")
    return configuration


def fake_solve(output_file, configuration, solve_cpus, overwrite):
    """Common solve logic because we do not really have separate routines"""
    with open(_log_file, "a+") as log_writer:
        if solve_cpus == 1:
            output_files = [output_file]
        else:
            output_files = [output_file.with_suffix(f"{_output_file_extension}{solve_cpu}") for solve_cpu in range(solve_cpus)]
        if any([output.is_file() for output in output_files]) and not overwrite:
            print("Output file(s) already exist. Exiting.", file=sys.stderr)
            sys.exit(3)
        for output in output_files:
            with open(output, 'w') as output_writer:
                log_writer.write(f"writing: {output}\n")
                output_writer.write(yaml.safe_dump(configuration))


def implicit(args):
    """Implicit routine"""
    configuration = configure(args)
    output_file = name_output_file(args.input_file, args.output_file)
    fake_solve(output_file, configuration, args.solve_cpus, args.overwrite)


def explicit(args):
    """Explicit routine"""
    configuration = configure(args)
    output_file = name_output_file(args.input_file, args.output_file)
    fake_solve(output_file, configuration, args.solve_cpus, args.overwrite)


def merge(args):
    """Merge parellized output files into a single output file"""
    pass


def positive_int(argument):
    """Type function for argparse - positive integers

    :param str argument: string argument from argparse

    :returns: argument
    :rtype: int

    :raises ValueError:

        * The argument can't be cast to int
        * The argument is less than 0
    """
    MINIMUM_VALUE = 0
    try:
        argument = int(argument)
    except ValueError:
        raise argparse.ArgumentTypeError("invalid integer value: '{}'".format(argument))
    if not argument > MINIMUM_VALUE:
        raise argparse.ArgumentTypeError("invalid positive integer: '{}'".format(argument))
    return argument


def get_parser():
    cli_description = "Dummy solver with file handling behavior similar to numeric solvers"
    main_parser = argparse.ArgumentParser(description=cli_description)
    main_parser.add_argument(
        "-V", "--version",
        action="version",
        version=_project_name_version
    )

    subcommand_parser_parent = argparse.ArgumentParser(add_help=False)
    required_named = subcommand_parser_parent.add_argument_group('required named arguments')
    required_named.add_argument(
        "-i", "--input-file", type=pathlib.Path, required=True,
        help=f"The {_project_name} input file, e.g. ``input_file.yaml``"
    )
    subcommand_parser_parent.add_argument(
        "-o", "--output-file", type=pathlib.Path, default=None, required=False,
        help=f"The {_project_name} results file. Extension is always replaced with ``{_output_file_extension}``. " \
             f"If none is provided, uses the pattern ``input_file{_output_file_extension}``"
    )
    subcommand_parser_parent.add_argument(
        "-n", "--solve-cpus", type=positive_int, default=1, required=False,
        help=f"The number of threads to use (default: %(default)s)"
    )
    subcommand_parser_parent.add_argument(
        "--overwrite", action="store_true",
        help=f"Overwrite existing output files (default: %(default)s)"
    )

    subparsers = main_parser.add_subparsers(
        # So args.subcommand will contain the name of the subcommand called
        title="subcommands",
        metavar="{subcommand}",
        dest="subcommand"
    )

    subparsers.add_parser(
        "implicit",
        help=f"Execute the {_project_name} implicit routine",
        parents=[subcommand_parser_parent]
    )

    subparsers.add_parser(
        "explicit",
        help=f"Execute the {_project_name} explicit routine",
        parents=[subcommand_parser_parent]
    )

    merge_parser = subparsers.add_parser(
        "merge",
        help=f"Merge output files (unimplemented)",
        parents=[subcommand_parser_parent]
    )

    return main_parser

if __name__ == "__main__":
    main()
